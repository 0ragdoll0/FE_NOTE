# HTTP/1.0

## 请求和回应
通信内容=头部（ASCII 码）+数据（各类格式）

### 请求
* GET/POST/HEAD / HTTP/1.0
* User-Agent
> 客户端信息
* Accept
> 可接收数据格式
* Accept-Encoding
> 可接收的压缩方式

### 回应
头信息 + 一个空行（\r\n） + 数据
* 协议版本 + 状态码（status code） + 状态描述
* Content-Type    
> 返回数据的格式（MIME type）（+;编码方式）      
> 例：Content-Type: text/html; charset=utf-8
* Content-Encoding
> 数据压缩方式

## 缺点
每个TCP连接只能发送一个请求。如果需要请求其他资源需要重新建立一个TCP连接，而TCP连接的建立需要客户端和服务器端三次握手，成本较高。

# HTTP/1.1
## 持久连接
TCP连接默认不关闭，进行复用，当客户端和服务器端发现对方一段时间没有活动，就可以主动关闭连接。

## 管道机制
客户端可以同时发送多个请求，但服务器按请求发出的顺序进行回应

## Transfer-Encoding: chunked
> "流模式"（stream）取代"缓存模式"（buffer）     
> 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。

## 新增
* 方法：PUT、PATCH、HEAD、 OPTIONS、DELETE
* 字段：Host（以将请求发往同一台服务器上的不同网站）

## 缺点
Head-of-line blocking：前面回应速度影响队列中后面的回应

# HTTP/2
以下均为相对于HTTP/1.1改进部分：
## 二进制协议
信息头和数据内容均为二进制

## 多工
TCP连接进行复用，回应可以不按顺序，避免队头堵塞

## 数据流
> 1. 由于回应可以不按顺序且连接复用，需要在一个连接中区分每个回应的数据包->每个回应的数据包称为一个数据流，用数据流ID来区分。
> 2. 客户端或服务器端可发送RST_STREAM中断数据流，且不中断TCP链接   
> 3. 客户端可指定数据流优先级

## 头信息压缩
HTTP 协议不带有状态，每次请求都必须附上所有信息。有一些发送的头信息，例如cookie和user agent每次重复，浪费带宽。          
> 解决方法：     
> 1. 头信息使用gzip或compress压缩后再发送     
> 2. 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号

## 服务器推送
服务器未经请求，主动向客户端发送资源

